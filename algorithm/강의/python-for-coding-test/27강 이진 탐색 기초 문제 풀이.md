# <문제 1> 떡볶이 떡 만들기

## 문제 설명

![](/.uploads2/2021-09-25-02-46-09.png)

## 문제 조건

![](/.uploads2/2021-09-25-02-47-39.png)

## 문제 해결 아이디어

![](/.uploads2/2021-09-25-02-51-43.png)

- 조건에서 자르는 높이 H 와 고객이 받게되는 떡의 길이 M 은 반비례

![](/.uploads2/2021-09-25-02-54-01.png)
![](/.uploads2/2021-09-25-02-58-11.png)
![](/.uploads2/2021-09-25-02-58-28.png)
![](/.uploads2/2021-09-25-02-58-41.png)
![](/.uploads2/2021-09-25-02-58-56.png)

## 답안 예시 (python)

![](/.uploads2/2021-09-25-03-01-26.png)

``` py
# 떡의 개수(N)와 요청한 떡의 길이(M) 을 입력
n, m = list(map(int, input().split(' ')))
# 각 떡의 개별 높이 정보를 입력
array = list(map(int, input().split()))

# 이진 탐색을 위한 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행 (반복적)
result = 0
while(start <= end):
  total = 0
  mid = (start + end) // 2
  for x in array:
    # 잘랐을 때의 떡의 양 계산
    if x > mid:
      total += x - mid
  # 떡의 양이 부족한 경우 더 많이 자르기 (왼쪽 부분 탐색)
  if total < m:
    end = mid - 1
  # 떡의 양이 충분한 경우 덜 자르기 (오른쪽 부분 탐색)
  else:
    result = mid # 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result 에 기록
    start = mid + 1
  
# 정답 출력
print(result)

'''
Input
4 6
19 15 10 17
Output
15
'''
```

# <문제 2> 정렬된 배열에서 특정 수의 개수 구하기

## 문제 설명

![](/.uploads2/2021-09-25-03-02-08.png)

## 문제 조건

![](/.uploads2/2021-09-25-03-02-52.png)

## 해결 아이디어

![](/.uploads2/2021-09-25-03-03-28.png)

## 답안 예시 (python)

![](/.uploads2/2021-09-25-03-04-22.png)

``` py
from bisect import bisect_left, bisect_right

# 값이 [left_value, right_value] 인 데이터의 개수를 반환하는 함수
def count_by_range(array, left_value, right_value):
  right_index = bisect_right(array, right_value)
  left_index = bisect_left(array,left_value)
  return right_index - left_index

n, x = map(int, input().split()) # 데이터의 개수 N, 찾고자 하는 값 x 입력받기
array = list(map(int, input().split())) # 전체 데이터 입력 받기

# 값이 [x, x] 범위에 있는 데이터의 개수 계산
count = count_by_range(array, x, x)

# 값이 x 인 원소가 존재하지 않는다면
if count == 0:
  print(-1)
# 값이 x 인 원소가 존재한다면
else:
  print(count)

'''
Input
7 2
1 1 2 2 2 2 3
Output
4
'''
```