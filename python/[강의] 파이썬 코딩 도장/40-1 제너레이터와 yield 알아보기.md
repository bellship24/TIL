**목차**

- [1. 요약](#1-요약)
- [2. 제너레이터란?](#2-제너레이터란)
- [3. 사용 방법](#3-사용-방법)
- [4. 작동 방식](#4-작동-방식)
- [5. 간단한 예제](#5-간단한-예제)
- [6. for 문과 제너레이터](#6-for-문과-제너레이터)
- [7. yield 의 동작 과정 알아보기](#7-yield-의-동작-과정-알아보기)
  - [7.1. 소스코드로 알아보기](#71-소스코드로-알아보기)
  - [7.2. next 와 yield 의 동작 과정](#72-next-와-yield-의-동작-과정)

**참고**

- [[책] 코딩 도장 - 40.1 제너레이터와 yield 알아보기](https://dojang.io/mod/page/view.php?id=2412)

# 1. 요약

- 제너레이터의 정의, 사용 방법, 작동 박식, 절차, 예제에 대해 알아보자.
- 제너레이터는 함수를 끝내지 않은 상태에서 yield 를 사용하여 값을 바깥으로 전달할 수 있음.
- return 은 반환 즉시 함수가 끝나지만 yield 는 잠시 함수 바깥의 코드가 실행되도록 양보하여 값을 가져가게 한 뒤 다시 제너레이터 안의 코드를 계속 실행하는 방식.

# 2. 제너레이터란?

- 제너레이터는 이터레이터를 생성해주는 함수.
- 제너레이터는 발생자라고도 함.
- 이터레이터는 클래스에 `__iter__`,  `__next__` 또는 `__getitem__` 메서드를 구현해야 하지만 제너레이터는 함수 안에서 `yield` 라는 키워드만 사용하면 끝. 그러므로 제너레이터가 이터레이터 보다 간단하게 작성 가능.
- `yield` 는 생상하다, 양보하다 라는 뜻. 즉, yield 를 사용하면 값을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보함. 따라서 yield 는 현재 함수를 잠시 중단하고 함수 바깥의 코드가 실행되도록 만듦.

# 3. 사용 방법

- 함수 안에서 `yield` 를 사용하면 함수는 제너레이터가 되며 `yield` 에는 값(변수) 를 지정함.

``` py
yield 값(또는 변수)
```

# 4. 작동 방식

- 제너레이터는 제너레이터 객체에서 `__next__` 메서드를 호출할 떄마다 함수 안의 `yield` 까지 코드를 실행하며 `yield` 에서 값을 발생시킴(generate). 그래서 이름이 제너레이터(generator)이다.
- 제너레이터는 값이 `__next__` 메서드의 반환값으로 나옴.
- 제너레이터는 함수의 끝까지 도달하면 StopIteration 예외가 자동으로 발생.

# 5. 간단한 예제

``` py
def number_generator():
  yield 0
  yield 1
  yield 2

for i in number_generator():
  print(i)

'''
0
1
2
'''
```

- for 반복문에 `number_generator()` 를 지정해서 값을 출력해보면 yield 에 지정했던 0, 1, 2 가 나옴.

# 6. for 문과 제너레이터

![](/.uploads2/2021-10-01-00-54-57.png)

- for 반복문은 반복할 때마다 `__next__` 를 호출하므로 `yield` 에서 발생시킨 값을 가져온다. 그리고 `StopIteration` 예외가 발생하면 반복을 끝냄.

# 7. yield 의 동작 과정 알아보기

## 7.1. 소스코드로 알아보기

- yield 의 동작 과정을 알아보기 위해 for 반복문 대신 `next` 함수로 `__next__` 메서드를 직접 호출해보자.

``` py
def number_generator():
  yield 0  # 0 을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보
  yield 1  # 1 을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보
  yield 2  # 2 를 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보

g = number_generator()

a = next(g)  # yield 를 사용하여 함수 바깥으로 전달한 값은 next 의 반환값으로 나옴
print(a)  # 0

b = next(g)
print(b)  # 1

c = next(g)
print(c)  # 2

'''
0
1
2
'''
```

- 앞서, `yield` 를 사용해 바깥으로 전달한 값은 `next` 함수의 반환값으로 나온다고 했으므로 `next(g)` 의 반환값을 출력해보면 `yield` 에 지정한 값 `0, 1, 2` 가 차례대로 나옴. 즉, 제너레이터 함수가 실행되는 중간에 `next` 로 값을 가져옴.

## 7.2. next 와 yield 의 동작 과정

yield 0 의 실행 양보

![](/.uploads2/2021-10-01-01-13-02.png)

- 먼저, `g = number_generator()` 와 같이 제너레이터 객체 생성.
- 그 다음, `next(g)` 를 호출하면 제너레이터 안의 `yield 0` 이 실행되어 숫자 0 을 전달한 뒤 바깥의 코드가 실행되도록 양보함.
- 함수 바깥에서는 print(a) 로 next(g) 에서 반환된 값을 출력.

yield 1 의 실행 양보

![](/.uploads2/2021-10-01-01-16-10.png)

- 값을 출력했으면 `b = next(g)` 로 다시 제너레이터 안의 코드를 실행.
- 이 때는 yield 1 이 실행되고 숫자 1을 발생시켜서 바깥으로 전달.
- 그리고 함수 바깥에서는 `print(b)` 로 `next(g)` 에서 반환된 값을 출력.

yield 2 의 실행 양보

![](/.uploads2/2021-10-01-01-17-03.png)

- 마찬가지로 yield 2 도 숫자를 발생시키고 print(c) 로 제너레이터에서 나온 값을 출력.